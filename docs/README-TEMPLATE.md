# [Your MCP Server Name]

> Generated by GRIMLOCK MCP Server Factory
>
> A production-ready Model Context Protocol server with intelligent pattern composition

## Table of Contents

- [Overview](#overview)
- [Why These Patterns Matter](#why-these-patterns-matter)
- [Architecture](#architecture)
- [Quick Start](#quick-start)
- [Configuration](#configuration)
- [Pattern Guide](#pattern-guide)
- [API Reference](#api-reference)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)

## Overview

### What This Server Does

[2-3 sentence description of the server's purpose and primary capabilities]

### Key Features

- **[Feature 1]**: [What it does and why it matters]
- **[Feature 2]**: [What it does and why it matters]
- **[Feature 3]**: [What it does and why it matters]

### Context Footprint

```
Base overhead:    ~XXX tokens per Claude call
Per tool:         ~YYY tokens
Total (N tools):  ~ZZZ tokens
```

**Why This Matters**: Every MCP server adds token overhead to EVERY Claude conversation. This server is optimized to provide maximum functionality with minimal context pollution. A poorly designed MCP server can consume 2000+ tokens per call, reducing Claude's working memory and increasing costs.

## Why These Patterns Matter

### The MCP Context Problem

Every tool you expose through MCP gets injected into Claude's context window on EVERY message. This means:

```
Without patterns:                With GRIMLOCK patterns:
┌─────────────────────┐         ┌─────────────────────┐
│ Tool 1: 800 tokens  │         │ Tool 1: 200 tokens  │
│ Tool 2: 750 tokens  │         │ Tool 2: 180 tokens  │
│ Tool 3: 900 tokens  │         │ Tool 3: 220 tokens  │
├─────────────────────┤         ├─────────────────────┤
│ Total: 2450 tokens  │         │ Total: 600 tokens   │
│ EVERY message!      │         │ EVERY message!      │
└─────────────────────┘         └─────────────────────┘
```

**The Impact**: That's 1850 tokens saved per message. Over a 50-message conversation, you've saved nearly 100K tokens - equivalent to 25+ pages of working memory for Claude.

### Pattern-Driven Architecture: Why Not Just "Write Good Code"?

You might ask: "Why generate code from patterns instead of just writing clean TypeScript?"

**The answer**: Consistency at scale.

```
Manual Approach:                 GRIMLOCK Approach:
┌─────────────────────┐         ┌─────────────────────┐
│ Dev A: try/catch    │         │ All tools: Unified  │
│ Dev B: custom error │         │ error handling with │
│ Dev C: no handling  │         │ MCP error codes     │
├─────────────────────┤         ├─────────────────────┤
│ Debugging: chaos    │         │ Debugging: patterns │
│ Inconsistent UX     │         │ Predictable UX      │
└─────────────────────┘         └─────────────────────┘
```

### Pattern Selection: What Each Pattern Prevents

#### Without Error Handling Pattern
```typescript
// What developers often write:
async function getTool(params: any) {
  const result = await externalAPI.fetch(params.id);
  return result;
}
```

**What breaks**:
- Network timeouts → Claude sees cryptic stack traces
- API errors → No user-friendly messages
- Invalid responses → Undefined behavior
- MCP clients → Don't understand the error type

#### With Error Handling Pattern
```typescript
// What GRIMLOCK generates:
async function getTool(params: ToolParams): Promise<ToolResult> {
  try {
    const result = await externalAPI.fetch(params.id);
    return { success: true, data: result };
  } catch (error) {
    if (error instanceof NetworkError) {
      throw new McpError(
        ErrorCode.InternalError,
        `Network timeout connecting to API: ${error.message}`,
        { retryable: true, timeout: error.timeout }
      );
    }
    // ... more specific error handling
  }
}
```

**What's prevented**:
- User-friendly error messages in Claude
- Proper MCP error codes for client handling
- Retry hints for transient failures
- Structured error data for debugging

## Architecture

### High-Level Flow

```
┌─────────────────────────────────────────────────────────────┐
│                        Claude Desktop                        │
│  (Calls MCP tool with user request)                         │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                     MCP Server Runtime                       │
│  ┌─────────────────────────────────────────────────────────┐│
│  │ Pattern Decorators (if enabled)                         ││
│  │                                                          ││
│  │  Retry Pattern ──► Validation Pattern ──► Progress      ││
│  │       │                   │                    │         ││
│  │       │                   │                    ▼         ││
│  │       │                   │          Long-Running Logic  ││
│  │       │                   │          (sends notifications)││
│  │       │                   │                    │         ││
│  │       │                   ▼                    │         ││
│  │       │          Input Validation              │         ││
│  │       │          (Zod schemas)                 │         ││
│  │       │                   │                    │         ││
│  │       ▼                   │                    │         ││
│  │  Error Handling           │                    │         ││
│  │  (3 retries, exponential backoff)              │         ││
│  │                           │                    │         ││
│  │                           ▼                    ▼         ││
│  │                  ┌─────────────────────────────┐         ││
│  │                  │   Business Logic (Tool)     │         ││
│  │                  │   - Your actual code        │         ││
│  │                  │   - External API calls      │         ││
│  │                  │   - Data processing         │         ││
│  │                  └─────────────────────────────┘         ││
│  └─────────────────────────────────────────────────────────┘│
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    Response to Claude                        │
│  - Structured result OR                                      │
│  - User-friendly error with MCP error code                   │
└─────────────────────────────────────────────────────────────┘
```

### Pattern Composition: How Decorators Stack

GRIMLOCK uses a decorator pattern to wrap your business logic in layers of cross-cutting concerns. Each pattern is composable and optional.

```typescript
// Conceptual view (actual implementation is generated):
const finalTool =
  retryPattern(
    longRunningPattern(
      progressNotificationPattern(
        validationPattern(
          errorHandlingPattern(
            yourBusinessLogic
          )
        )
      )
    )
  );
```

**Execution Order** (outside-in):
1. **Retry**: Catches transient failures, retries with backoff
2. **Long-Running**: Sets up timeout handling for operations >30s
3. **Progress**: Sends notifications to Claude during execution
4. **Validation**: Validates input against Zod schema
5. **Error Handling**: Wraps business logic, translates errors to MCP format
6. **Your Business Logic**: The actual tool implementation

### Generated Code Structure

```
your-mcp-server/
├── src/
│   ├── index.ts              # Server entry point, tool registration
│   ├── tools/
│   │   ├── tool1.ts          # Generated tool with patterns
│   │   ├── tool2.ts          # Generated tool with patterns
│   │   └── tool3.ts          # Generated tool with patterns
│   ├── patterns/
│   │   ├── error-handling.ts # Error types + MCP error mapping
│   │   ├── validation.ts     # Zod schemas for all tools
│   │   ├── retry.ts          # Exponential backoff retry logic
│   │   ├── progress.ts       # Progress notification helpers
│   │   └── logging.ts        # Structured logging setup
│   ├── types/
│   │   └── index.ts          # Shared TypeScript types
│   └── config.ts             # Configuration management
├── tests/
│   ├── tools/                # Unit tests for each tool
│   └── integration/          # Integration tests
└── package.json              # Dependencies + scripts
```

**Why This Structure**:
- **Patterns in separate files**: Easy to audit, modify, or disable
- **One file per tool**: Grep-friendly, testable in isolation
- **Types centralized**: Single source of truth for interfaces
- **Tests mirror src**: Easy to find corresponding tests

## Quick Start

### Installation

```bash
npm install
```

### Environment Setup

```bash
cp .env.example .env
# Edit .env with your configuration
```

**Required Environment Variables**:
```bash
# [List required vars with explanations]
API_KEY=your_api_key          # Used for [purpose]
API_ENDPOINT=https://...      # Base URL for [service]
LOG_LEVEL=info                # debug|info|warn|error
```

### Running the Server

#### Development Mode (with hot reload)
```bash
npm run dev
```

#### Production Mode
```bash
npm run build
npm start
```

### Connecting to Claude Desktop

Add to your Claude Desktop configuration (`~/Library/Application Support/Claude/claude_desktop_config.json`):

```json
{
  "mcpServers": {
    "[your-server-name]": {
      "command": "node",
      "args": ["/absolute/path/to/your-mcp-server/dist/index.js"],
      "env": {
        "API_KEY": "your_api_key",
        "LOG_LEVEL": "info"
      }
    }
  }
}
```

**Restart Claude Desktop** to load the server.

### Verification

In Claude Desktop, start a conversation and try:
```
Can you list the available tools from [your-server-name]?
```

You should see [N] tools available.

## Configuration

### Pattern Configuration

Patterns are configured in `src/config.ts`. Each pattern can be enabled/disabled globally or per-tool.

```typescript
export const config = {
  patterns: {
    errorHandling: {
      enabled: true,
      // Error handling is always recommended
    },
    validation: {
      enabled: true,
      // Disable for performance-critical, trusted inputs
    },
    retry: {
      enabled: true,
      maxRetries: 3,
      initialDelayMs: 1000,
      // Disable if your API has its own retry logic
    },
    progress: {
      enabled: true,
      notificationIntervalMs: 5000,
      // Disable for tools that complete <10s
    },
    longRunning: {
      enabled: true,
      timeoutMs: 300000, // 5 minutes
      // Adjust based on expected operation duration
    }
  }
};
```

### Per-Tool Pattern Overrides

Some tools may need different pattern configurations:

```typescript
// In src/tools/heavyweight-operation.ts
export const toolConfig = {
  patterns: {
    longRunning: {
      timeoutMs: 600000, // 10 minutes for this specific tool
    },
    progress: {
      notificationIntervalMs: 2000, // More frequent updates
    }
  }
};
```

## Pattern Guide

### When to Enable Each Pattern

#### Error Handling Pattern
**Always enable** unless you have a very specific reason not to.

**Provides**:
- Custom error types (`ValidationError`, `NetworkError`, `APIError`)
- MCP error code mapping
- User-friendly error messages
- Structured error metadata

**Cost**: ~50 tokens per tool

**Disable when**:
- Never (seriously, don't disable this)

---

#### Input Validation Pattern
**Enable by default**, disable for performance-critical paths with trusted input.

**Provides**:
- Zod schema validation
- Type coercion (strings → numbers, etc.)
- Clear validation error messages
- Runtime type safety

**Cost**: ~80 tokens per tool (includes schema definition)

**Disable when**:
- Input comes from trusted internal source
- Performance is critical (>100 calls/second)
- You have custom validation logic

**Example - With Validation**:
```typescript
// User calls tool with invalid input
{ "age": "not-a-number" }

// Claude sees user-friendly error:
"Validation error: age must be a number between 0 and 150"
```

**Example - Without Validation**:
```typescript
// User calls tool with invalid input
{ "age": "not-a-number" }

// Claude sees cryptic error:
"TypeError: Cannot perform arithmetic on NaN at line 47"
```

---

#### Retry Pattern
**Enable for tools calling external APIs**, disable for local operations.

**Provides**:
- Exponential backoff retry logic
- Configurable retry attempts
- Transient failure handling
- Jitter to prevent thundering herd

**Cost**: ~60 tokens per tool

**Enable when**:
- Calling external APIs (network failures are common)
- Interacting with databases (connection pools can be exhausted)
- File system operations (temporary locks, NFS issues)

**Disable when**:
- Pure computation (no I/O)
- User input errors (retrying won't help)
- Operations with side effects (don't want duplicate charges)

**Configuration**:
```typescript
retry: {
  maxRetries: 3,              // Total attempts: 1 initial + 3 retries
  initialDelayMs: 1000,       // First retry after 1s
  maxDelayMs: 30000,          // Cap at 30s
  backoffMultiplier: 2        // Exponential: 1s, 2s, 4s, 8s...
}
```

---

#### Progress Notification Pattern
**Enable for operations >10 seconds**, disable for quick operations.

**Provides**:
- Real-time progress updates to Claude
- User sees "Working on it..." instead of timeout anxiety
- Structured progress messages
- Cancellation support (future)

**Cost**: ~40 tokens per tool

**Enable when**:
- File uploads/downloads
- Batch processing
- External API calls with unpredictable latency
- Multi-step workflows

**Disable when**:
- Operations complete in <10 seconds
- No meaningful progress to report
- Operating in high-frequency mode (>10 calls/minute)

**User Experience**:
```
Without progress:
User: "Process these 1000 files"
Claude: [30 seconds of silence]
User: "Is it broken?"

With progress:
User: "Process these 1000 files"
Claude: "Processing files... 250/1000 complete (25%)"
Claude: "Processing files... 500/1000 complete (50%)"
Claude: "Processing files... 750/1000 complete (75%)"
Claude: "Processing complete! 1000 files processed."
```

---

#### Long-Running Pattern
**Enable for operations that might exceed 60 seconds**.

**Provides**:
- Configurable timeouts
- Graceful timeout handling
- Clear timeout error messages
- Prevents zombie processes

**Cost**: ~30 tokens per tool

**Enable when**:
- Video/audio processing
- Large file operations
- Complex computations
- Batch API calls

**Disable when**:
- Guaranteed fast operations (<30s)
- External service handles timeouts
- Using progress pattern (often redundant)

**Configuration**:
```typescript
longRunning: {
  timeoutMs: 300000,          // 5 minutes
  gracefulShutdownMs: 5000    // 5s to clean up before force-kill
}
```

---

#### Graceful Degradation Pattern
**Enable when you have fallback options**.

**Provides**:
- Fallback to alternative data sources
- Cached data when live API fails
- Partial results instead of total failure
- Service availability checks

**Cost**: ~70 tokens per tool

**Enable when**:
- Multiple data sources available (primary + backup)
- Cached data is acceptable fallback
- Partial results are useful (e.g., 8/10 items)

**Disable when**:
- Only one data source exists
- Partial results are useless
- Correctness > availability

**Example**:
```typescript
// Without graceful degradation:
async function getWeather(city: string) {
  return await weatherAPI.fetch(city); // Fails if API is down
}

// With graceful degradation:
async function getWeather(city: string) {
  try {
    return await weatherAPI.fetch(city);
  } catch (error) {
    console.warn('Live API failed, using cached data');
    return await cache.get(city); // 1-hour old data is better than nothing
  }
}
```

---

#### Logging Pattern
**Always enable in development**, use structured logging in production.

**Provides**:
- Structured JSON logs
- Configurable log levels
- Request/response logging
- Performance metrics

**Cost**: ~20 tokens per tool

**Configuration**:
```typescript
logging: {
  level: 'info',              // debug|info|warn|error
  format: 'json',             // json|pretty
  includeTimestamps: true,
  includeMetadata: true,      // Request IDs, user context
  redactSecrets: true         // Auto-redact API keys, tokens
}
```

## API Reference

### Tools

#### `[tool-name]`

**Description**: [What the tool does]

**Parameters**:
```typescript
{
  param1: string;    // Description
  param2?: number;   // Optional description
}
```

**Returns**:
```typescript
{
  result: string;
  metadata: {
    // ...
  };
}
```

**Example Usage in Claude**:
```
User: "Can you [do the thing] with [parameters]?"
Claude: [Uses tool, shows result]
```

**Errors**:
- `InvalidInput`: When [condition]
- `APIError`: When [condition]
- `NotFound`: When [condition]

**Patterns Enabled**:
- [x] Error Handling
- [x] Input Validation
- [x] Retry (3 attempts)
- [ ] Progress Notifications (completes too quickly)
- [ ] Long-Running (typical duration: 2-5s)

---

[Repeat for each tool]

## Troubleshooting

### Common Issues

#### "Tool not found" in Claude Desktop

**Symptoms**: Claude says it doesn't have access to your tools.

**Causes**:
1. Server not in Claude Desktop config
2. Server crashed on startup
3. Path in config is incorrect

**Solutions**:
```bash
# 1. Check server logs
tail -f ~/.claude/logs/mcp-server-*.log

# 2. Verify config path is absolute
# In claude_desktop_config.json:
"args": ["/full/absolute/path/to/dist/index.js"]  # ✓
"args": ["./dist/index.js"]                        # ✗

# 3. Test server standalone
node dist/index.js
# Should output: "Server listening on stdio"

# 4. Restart Claude Desktop
# Servers only load on startup
```

---

#### "Timeout" errors for fast operations

**Symptoms**: Tools that should complete quickly are timing out.

**Causes**:
- Synchronous blocking operations
- Missing await on promises
- Network issues

**Solutions**:
```typescript
// BAD: Synchronous operation blocks event loop
function processTool(params) {
  const result = heavyComputation(); // Blocks for 10 seconds
  return result;
}

// GOOD: Break into async chunks
async function processTool(params) {
  const chunks = splitWork(params);
  const results = [];
  for (const chunk of chunks) {
    results.push(await processChunk(chunk));
    await setImmediate(); // Let event loop breathe
  }
  return results;
}
```

---

#### "Validation failed" for correct input

**Symptoms**: Zod validation rejects input that looks correct.

**Causes**:
- Type mismatch (string vs number)
- Missing required fields
- Schema too strict

**Solutions**:
```typescript
// Check what Claude is actually sending
// In your tool implementation:
console.log('Received params:', JSON.stringify(params, null, 2));

// Common fix: Coerce types in schema
const schema = z.object({
  age: z.coerce.number(),     // Accepts "42" or 42
  active: z.coerce.boolean(), // Accepts "true" or true
});
```

---

#### High token usage in Claude

**Symptoms**: Conversations hit token limits quickly.

**Causes**:
- Too many tools exposed
- Verbose tool descriptions
- Large schemas in context

**Solutions**:
1. **Audit tool descriptions**:
   ```typescript
   // BAD: 200 tokens
   description: `This tool allows you to retrieve comprehensive user information
   including their profile data, preferences, activity history, and related metadata
   from the database. It supports filtering by various criteria and returns detailed
   results in JSON format.`

   // GOOD: 40 tokens
   description: `Get user profile data by ID. Returns profile, preferences, and activity.`
   ```

2. **Split into multiple servers**:
   ```json
   {
     "mcpServers": {
       "core-tools": { /* High-frequency tools */ },
       "admin-tools": { /* Rarely used tools */ }
     }
   }
   ```

   Only load servers you need for the current task.

3. **Use resource URIs instead of full data**:
   ```typescript
   // BAD: Return full objects
   { users: [{ id: 1, name: "...", email: "...", ... }] }

   // GOOD: Return URIs
   { users: ["user://1", "user://2"] }
   // Claude can fetch details only if needed
   ```

---

### Debug Mode

Enable verbose logging:

```bash
# In .env
LOG_LEVEL=debug

# Or runtime
DEBUG=* node dist/index.js
```

**Debug output includes**:
- All tool invocations
- Pattern execution trace
- Validation results
- Retry attempts
- Performance timings

## Performance Characteristics

### Latency by Pattern

| Pattern | Added Latency | When It Matters |
|---------|---------------|-----------------|
| Error Handling | <1ms | Never |
| Validation | 1-5ms | High-frequency calls |
| Retry | 0ms (success), +seconds (failure) | Only on retries |
| Progress | 5-10ms per update | Long operations only |
| Long-Running | <1ms | Never |
| Logging | 1-3ms | High-frequency calls |

### Throughput

**Without patterns**: ~1000 calls/second (limited by business logic)
**With all patterns**: ~800 calls/second (-20% overhead)

**Recommendation**: Patterns are designed for correctness, not maximum throughput. If you need >500 calls/second, you probably shouldn't be using MCP (use a direct API instead).

### Memory Usage

**Base server**: ~50MB
**Per active tool call**: ~2-5MB
**With progress notifications**: +10MB (buffering)

**Recommendation**: Set `NODE_OPTIONS=--max-old-space-size=512` for typical usage.

## Anti-Patterns (What NOT to Do)

### ❌ Don't Disable Error Handling to "Simplify"
```typescript
// Never do this
try {
  return await riskyOperation();
} catch (e) {
  // Silence errors, hope for the best
}
```
**Why it's bad**: Claude sees no feedback, user has no idea what went wrong.

---

### ❌ Don't Use MCP for High-Frequency APIs
```typescript
// Bad: Streaming data through MCP
setInterval(() => {
  mcp.notifyDataUpdate(latestStockPrice);
}, 100); // 10 times per second
```
**Why it's bad**: MCP is designed for discrete tool calls, not streaming. Use WebSockets or SSE.

---

### ❌ Don't Put Secrets in Tool Descriptions
```typescript
// Bad: Leaking credentials
const tool = {
  description: `Connect to database at postgresql://admin:password123@...`
};
```
**Why it's bad**: Tool descriptions are sent to Claude, logged, and potentially cached.

---

### ❌ Don't Return Massive Payloads
```typescript
// Bad: 100MB response
async function getAllUsers() {
  return database.users.findAll(); // 1 million rows
}
```
**Why it's bad**: Claude has token limits. Return paginated results or summaries.

**Good**:
```typescript
async function getAllUsers(limit = 100, offset = 0) {
  const users = await database.users.findMany({ limit, offset });
  const total = await database.users.count();
  return {
    users: users.slice(0, limit),
    pagination: { limit, offset, total }
  };
}
```

---

### ❌ Don't Block the Event Loop
```typescript
// Bad: Synchronous blocking
function hashPassword(password: string) {
  return bcrypt.hashSync(password, 10); // Blocks for 100ms+
}
```

**Good**:
```typescript
async function hashPassword(password: string) {
  return await bcrypt.hash(password, 10); // Non-blocking
}
```

---

## Testing

### Unit Tests

```bash
npm test                  # Run all tests
npm test -- --watch      # Watch mode
npm test -- tool1        # Test specific tool
```

### Integration Tests

```bash
npm run test:integration  # Requires external services
```

### Manual Testing with MCP Inspector

```bash
npx @modelcontextprotocol/inspector dist/index.js
```

Opens a web UI to manually invoke tools and inspect results.

## Contributing

### Adding a New Tool

1. Generate PRD specification (see GRIMLOCK docs)
2. Run GRIMLOCK code generator
3. Review generated code in `src/tools/`
4. Add tests in `tests/tools/`
5. Update this README's API Reference section

### Modifying Patterns

**Before modifying patterns**, understand the impact:

```bash
# See which tools use a pattern
grep -r "errorHandling" src/tools/

# Run tests to ensure no breakage
npm test
```

**Pattern modification checklist**:
- [ ] Update pattern implementation
- [ ] Update pattern tests
- [ ] Update affected tool tests
- [ ] Update this README's Pattern Guide
- [ ] Verify token count hasn't increased significantly

### Code Style

- **TypeScript**: Strict mode enabled
- **Linting**: ESLint + Prettier
- **Formatting**: `npm run format`

## License

[Your license here]

## Support

- **Issues**: [GitHub Issues](https://github.com/...)
- **Discussions**: [GitHub Discussions](https://github.com/...)
- **Email**: [your-email]

---

## Appendix: Pattern Implementation Details

### Error Handling Pattern Implementation

```typescript
// Generated in src/patterns/error-handling.ts

export class McpError extends Error {
  constructor(
    public code: ErrorCode,
    message: string,
    public metadata?: Record<string, unknown>
  ) {
    super(message);
    this.name = 'McpError';
  }
}

export enum ErrorCode {
  InvalidParams = -32602,
  InternalError = -32603,
  // ... MCP error codes
}

export function wrapWithErrorHandling<T>(
  fn: (...args: any[]) => Promise<T>
): (...args: any[]) => Promise<T> {
  return async (...args: any[]) => {
    try {
      return await fn(...args);
    } catch (error) {
      if (error instanceof McpError) {
        throw error; // Already formatted
      }

      // Translate to MCP error
      throw new McpError(
        ErrorCode.InternalError,
        error instanceof Error ? error.message : 'Unknown error',
        { originalError: error }
      );
    }
  };
}
```

### Retry Pattern Implementation

```typescript
// Generated in src/patterns/retry.ts

export async function withRetry<T>(
  fn: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> {
  const {
    maxRetries = 3,
    initialDelayMs = 1000,
    maxDelayMs = 30000,
    backoffMultiplier = 2,
    shouldRetry = (error) => isTransient(error)
  } = options;

  let lastError: Error;

  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      lastError = error;

      if (!shouldRetry(error) || attempt === maxRetries) {
        throw error;
      }

      const delay = Math.min(
        initialDelayMs * Math.pow(backoffMultiplier, attempt),
        maxDelayMs
      );

      const jitter = delay * 0.1 * Math.random();
      await sleep(delay + jitter);
    }
  }

  throw lastError;
}

function isTransient(error: unknown): boolean {
  // Network errors, timeouts, 5xx responses
  return error instanceof NetworkError ||
         error instanceof TimeoutError ||
         (error instanceof APIError && error.status >= 500);
}
```

---

**Generated by GRIMLOCK MCP Server Factory v1.0.0**
