{{!--
  Validated Tool Wrapper Template

  A higher-order function that wraps MCP tools with:
  - Automatic input validation
  - Error boundary
  - Optional retry logic
  - Progress notification support for long-running operations

  Usage:
    Import and use to wrap tool implementations with consistent validation and error handling.

  Placeholders:
    {{MAX_RETRIES}}     - Maximum retry attempts (default: 3)
    {{RETRY_DELAY_MS}}  - Base delay between retries in ms (default: 1000)
--}}
import { z, ZodSchema, ZodError } from 'zod';
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { CallToolResult } from '@modelcontextprotocol/sdk/types.js';
import {
  McpError,
  McpErrorCode,
  ValidationError,
  isMcpError,
} from './error-types';
import {
  handleMcpError,
  McpErrorResponse,
  ErrorHandlerOptions,
  ErrorLogger,
} from './error-handler';

/**
 * Configuration for the validated tool wrapper.
 */
export interface ValidatedToolWrapperConfig<TInput, TOutput> {
  /** Tool name for logging and error context */
  name: string;
  /** Tool description for MCP registration */
  description: string;
  /** Zod schema for input validation */
  inputSchema: ZodSchema<TInput>;
  /** The actual tool implementation */
  handler: (input: TInput, context: ToolContext) => Promise<TOutput>;
  /** Optional retry configuration */
  retry?: RetryConfig;
  /** Optional progress notification configuration */
  progress?: ProgressConfig;
  /** Custom logger */
  logger?: ErrorLogger;
  /** Custom error handler options */
  errorHandlerOptions?: Partial<ErrorHandlerOptions>;
}

/**
 * Retry configuration for transient failures.
 */
export interface RetryConfig {
  /** Maximum number of retry attempts */
  maxRetries: number;
  /** Base delay between retries in milliseconds */
  baseDelayMs: number;
  /** Whether to use exponential backoff */
  exponentialBackoff: boolean;
  /** Maximum delay between retries */
  maxDelayMs: number;
  /** Error codes that should trigger retry */
  retryableErrorCodes: McpErrorCode[];
  /** Custom retry condition function */
  shouldRetry?: (error: McpError, attempt: number) => boolean;
}

/**
 * Progress notification configuration.
 */
export interface ProgressConfig {
  /** Enable progress notifications */
  enabled: boolean;
  /** Interval for progress updates in milliseconds */
  intervalMs: number;
  /** Custom progress message generator */
  messageGenerator?: (elapsed: number, attempt: number) => string;
}

/**
 * Context passed to tool handlers.
 */
export interface ToolContext {
  /** Current retry attempt (0 for first attempt) */
  attempt: number;
  /** Abort signal for cancellation */
  signal?: AbortSignal;
  /** Function to report progress */
  reportProgress: (message: string, progress?: number) => void;
  /** MCP server instance for notifications */
  server?: Server;
  /** Request metadata */
  meta?: {
    progressToken?: string | number;
  };
}

/**
 * Default retry configuration.
 */
const DEFAULT_RETRY_CONFIG: RetryConfig = {
  maxRetries: {{#if MAX_RETRIES}}{{MAX_RETRIES}}{{else}}3{{/if}},
  baseDelayMs: {{#if RETRY_DELAY_MS}}{{RETRY_DELAY_MS}}{{else}}1000{{/if}},
  exponentialBackoff: true,
  maxDelayMs: 30000,
  retryableErrorCodes: [
    McpErrorCode.RATE_LIMIT,
    McpErrorCode.TIMEOUT,
    McpErrorCode.SERVICE_UNAVAILABLE,
  ],
};

/**
 * Default progress configuration.
 */
const DEFAULT_PROGRESS_CONFIG: ProgressConfig = {
  enabled: false,
  intervalMs: 5000,
};

/**
 * Default logger implementation.
 */
const defaultLogger: ErrorLogger = {
  error: (msg, ctx) => console.error(`[ERROR] ${msg}`, ctx),
  warn: (msg, ctx) => console.warn(`[WARN] ${msg}`, ctx),
  info: (msg, ctx) => console.info(`[INFO] ${msg}`, ctx),
};

/**
 * Calculates delay for retry with optional exponential backoff.
 */
function calculateRetryDelay(
  attempt: number,
  config: RetryConfig,
  error?: McpError
): number {
  // Use retry-after from error if available
  if (error?.details.retryAfterMs) {
    return Math.min(error.details.retryAfterMs, config.maxDelayMs);
  }

  if (config.exponentialBackoff) {
    const delay = config.baseDelayMs * Math.pow(2, attempt);
    // Add jitter to prevent thundering herd
    const jitter = Math.random() * 0.3 * delay;
    return Math.min(delay + jitter, config.maxDelayMs);
  }

  return config.baseDelayMs;
}

/**
 * Sleep utility for retry delays.
 */
function sleep(ms: number, signal?: AbortSignal): Promise<void> {
  return new Promise((resolve, reject) => {
    const timeout = setTimeout(resolve, ms);
    signal?.addEventListener('abort', () => {
      clearTimeout(timeout);
      reject(new McpError(McpErrorCode.TIMEOUT, 'Operation aborted'));
    });
  });
}

/**
 * Determines if an error should trigger a retry.
 */
function shouldRetryError(
  error: McpError,
  attempt: number,
  config: RetryConfig
): boolean {
  // Check max retries
  if (attempt >= config.maxRetries) {
    return false;
  }

  // Check retryable flag from error
  if (!error.details.retryable) {
    return false;
  }

  // Check custom retry condition
  if (config.shouldRetry) {
    return config.shouldRetry(error, attempt);
  }

  // Check error code
  return config.retryableErrorCodes.includes(error.code);
}

/**
 * Type for the wrapped handler function.
 */
export type WrappedToolHandler = (
  args: unknown,
  meta?: { progressToken?: string | number },
  server?: Server
) => Promise<CallToolResult>;

/**
 * Creates a validated tool wrapper with automatic validation, error handling,
 * optional retry logic, and progress notification support.
 *
 * @param config - Wrapper configuration
 * @returns Wrapped tool handler function
 *
 * @example
 * ```typescript
 * const getCustomerTool = createValidatedToolWrapper({
 *   name: 'get_customer',
 *   description: 'Retrieve customer by ID',
 *   inputSchema: z.object({ id: z.string().uuid() }),
 *   handler: async (input, context) => {
 *     context.reportProgress('Fetching customer...');
 *     const customer = await customerService.get(input.id);
 *     return customer;
 *   },
 *   retry: {
 *     maxRetries: 3,
 *     baseDelayMs: 1000,
 *     exponentialBackoff: true,
 *     maxDelayMs: 10000,
 *     retryableErrorCodes: [McpErrorCode.TIMEOUT, McpErrorCode.RATE_LIMIT],
 *   },
 *   progress: {
 *     enabled: true,
 *     intervalMs: 2000,
 *   },
 * });
 * ```
 */
export function createValidatedToolWrapper<TInput, TOutput>(
  config: ValidatedToolWrapperConfig<TInput, TOutput>
): WrappedToolHandler {
  const {
    name,
    inputSchema,
    handler,
    retry = DEFAULT_RETRY_CONFIG,
    progress = DEFAULT_PROGRESS_CONFIG,
    logger = defaultLogger,
    errorHandlerOptions = {},
  } = config;

  return async (
    args: unknown,
    meta?: { progressToken?: string | number },
    server?: Server
  ): Promise<CallToolResult> => {
    // Step 1: Validate input
    const parseResult = inputSchema.safeParse(args);

    if (!parseResult.success) {
      const validationError = ValidationError.fromZodError(
        parseResult.error,
        `${name} input`
      );
      return handleMcpError(validationError, {
        toolName: name,
        logger,
        ...errorHandlerOptions,
      });
    }

    const validatedInput = parseResult.data;

    // Step 2: Set up progress reporting
    let progressInterval: NodeJS.Timeout | undefined;
    const startTime = Date.now();

    const reportProgress = (message: string, progressValue?: number): void => {
      if (server && meta?.progressToken !== undefined) {
        server.notification({
          method: 'notifications/progress',
          params: {
            progressToken: meta.progressToken,
            progress: progressValue ?? -1,
            total: progressValue !== undefined ? 100 : undefined,
            message,
          },
        }).catch((err) => {
          logger.warn(`Failed to send progress notification: ${err}`);
        });
      }
    };

    // Start progress interval if enabled
    if (progress.enabled && server && meta?.progressToken !== undefined) {
      let intervalCount = 0;
      progressInterval = setInterval(() => {
        intervalCount++;
        const elapsed = Date.now() - startTime;
        const message = progress.messageGenerator
          ? progress.messageGenerator(elapsed, 0)
          : `${name} in progress... (${Math.round(elapsed / 1000)}s elapsed)`;
        reportProgress(message);
      }, progress.intervalMs);
    }

    // Step 3: Execute with retry logic
    let lastError: McpError | undefined;
    let attempt = 0;

    try {
      while (attempt <= retry.maxRetries) {
        try {
          const context: ToolContext = {
            attempt,
            reportProgress,
            server,
            meta,
          };

          // Execute handler
          const result = await handler(validatedInput, context);

          // Format successful response
          return {
            content: [
              {
                type: 'text',
                text: typeof result === 'string' ? result : JSON.stringify(result, null, 2),
              },
            ],
          };
        } catch (error) {
          // Convert to McpError if needed
          const mcpError = isMcpError(error)
            ? error
            : new McpError(
                McpErrorCode.INTERNAL_ERROR,
                error instanceof Error ? error.message : String(error),
                { cause: error instanceof Error ? error : undefined }
              );

          lastError = mcpError;

          // Check if we should retry
          if (shouldRetryError(mcpError, attempt, retry)) {
            const delay = calculateRetryDelay(attempt, retry, mcpError);
            logger.warn(`${name} failed, retrying in ${delay}ms (attempt ${attempt + 1}/${retry.maxRetries})`, {
              error: mcpError.message,
              errorCode: mcpError.code,
            });

            reportProgress(`Retrying... (attempt ${attempt + 2}/${retry.maxRetries + 1})`);
            await sleep(delay);
            attempt++;
            continue;
          }

          // Not retryable, throw to outer catch
          throw mcpError;
        }
      }

      // Exhausted retries
      throw lastError ?? new McpError(
        McpErrorCode.INTERNAL_ERROR,
        `${name} failed after ${retry.maxRetries} retries`
      );
    } catch (error) {
      return handleMcpError(error, {
        toolName: name,
        logger,
        ...errorHandlerOptions,
      });
    } finally {
      // Clean up progress interval
      if (progressInterval) {
        clearInterval(progressInterval);
      }
    }
  };
}

/**
 * Creates a tool definition object for MCP server registration.
 */
export function createToolDefinition<TInput>(
  name: string,
  description: string,
  inputSchema: ZodSchema<TInput>
): {
  name: string;
  description: string;
  inputSchema: {
    type: 'object';
    properties: Record<string, unknown>;
    required: string[];
  };
} {
  // Extract schema shape for MCP registration
  const shape = (inputSchema as z.ZodObject<z.ZodRawShape>).shape ?? {};
  const properties: Record<string, unknown> = {};
  const required: string[] = [];

  for (const [key, value] of Object.entries(shape)) {
    const zodType = value as z.ZodTypeAny;
    properties[key] = zodToJsonSchema(zodType);

    // Check if field is required (not optional and not nullable with default)
    if (!zodType.isOptional() && !zodType.isNullable()) {
      required.push(key);
    }
  }

  return {
    name,
    description,
    inputSchema: {
      type: 'object',
      properties,
      required,
    },
  };
}

/**
 * Converts Zod schema to JSON Schema for MCP registration.
 * Basic implementation - extend as needed for complex types.
 */
function zodToJsonSchema(schema: z.ZodTypeAny): Record<string, unknown> {
  const description = schema.description;
  const base: Record<string, unknown> = {};

  if (description) {
    base.description = description;
  }

  // Handle wrapped types
  if (schema instanceof z.ZodOptional || schema instanceof z.ZodNullable) {
    return { ...base, ...zodToJsonSchema(schema.unwrap()) };
  }

  if (schema instanceof z.ZodDefault) {
    const inner = zodToJsonSchema(schema._def.innerType);
    return { ...base, ...inner, default: schema._def.defaultValue() };
  }

  // Handle primitive types
  if (schema instanceof z.ZodString) {
    return { ...base, type: 'string' };
  }

  if (schema instanceof z.ZodNumber) {
    return { ...base, type: 'number' };
  }

  if (schema instanceof z.ZodBoolean) {
    return { ...base, type: 'boolean' };
  }

  if (schema instanceof z.ZodArray) {
    return {
      ...base,
      type: 'array',
      items: zodToJsonSchema(schema.element),
    };
  }

  if (schema instanceof z.ZodObject) {
    const properties: Record<string, unknown> = {};
    const required: string[] = [];

    for (const [key, value] of Object.entries(schema.shape)) {
      properties[key] = zodToJsonSchema(value as z.ZodTypeAny);
      const zodValue = value as z.ZodTypeAny;
      if (!zodValue.isOptional()) {
        required.push(key);
      }
    }

    return {
      ...base,
      type: 'object',
      properties,
      ...(required.length > 0 ? { required } : {}),
    };
  }

  if (schema instanceof z.ZodEnum) {
    return { ...base, type: 'string', enum: schema.options };
  }

  if (schema instanceof z.ZodLiteral) {
    return { ...base, const: schema.value };
  }

  if (schema instanceof z.ZodUnion) {
    return {
      ...base,
      oneOf: schema.options.map((opt: z.ZodTypeAny) => zodToJsonSchema(opt)),
    };
  }

  // Fallback for unknown types
  return { ...base, type: 'object' };
}

/**
 * Utility type to extract input type from a validated tool wrapper config.
 */
export type InferInput<T> = T extends ValidatedToolWrapperConfig<infer I, unknown>
  ? I
  : never;

/**
 * Utility type to extract output type from a validated tool wrapper config.
 */
export type InferOutput<T> = T extends ValidatedToolWrapperConfig<unknown, infer O>
  ? O
  : never;
